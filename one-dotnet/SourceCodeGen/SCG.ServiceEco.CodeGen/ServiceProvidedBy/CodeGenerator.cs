using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace TPFive.SCG.ServiceEco.CodeGen.ServiceProvidedBy
{
    internal static class CodeGenerator
    {
        public static string Generate(
            ClassModel model,
            IReadOnlyList<(INamedTypeSymbol Symbol, InterfaceDeclarationSyntax Syntax)> nodes,
            string fullName)
        {
            var output = $@"
// <auto-generated />

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.SceneManagement;
using VContainer;
using VContainer.Unity;

namespace {model.Namespace}
{{
    /// <summary>
    /// This is the default service provider for related service.
    /// </summary>
    public class NullServiceProvider :
        {model.Namespace}.IServiceProvider
    {{
        /// <summary>
        /// Action with multiple parameters.
        /// </summary>
        private readonly T1MultiObjParamDelegate<string> _actionHandler;

        public NullServiceProvider(
            T1MultiObjParamDelegate<string> actionHandler)
        {{
            _actionHandler = actionHandler;
        }}
";
            var code = GenerateBasedOnNodes(nodes);
            output = $"{output}{code}";

            var endMethod = $@"
    }}
}}
";
            output = $"{output}{endMethod}";

            return output;
        }

        private static string GenerateBasedOnNodes(
            IReadOnlyList<(INamedTypeSymbol Symbol, InterfaceDeclarationSyntax Syntax)> nodes)
        {
            // Using string builder as it is clear than multi line string literal.
            var sb = new StringBuilder();

            foreach (var (x, z) in nodes)
            {
                if (x.Name.Contains("IServiceProvider"))
                {
                    var eventSyntaxs = z.DescendantNodes().OfType<EventFieldDeclarationSyntax>();

                    foreach (var eventSyntax in eventSyntaxs)
                    {
                        sb.AppendLine($"        public event {eventSyntax.Declaration.Type} {eventSyntax.Declaration.Variables};");
                        sb.AppendLine(string.Empty);
                    }

                    var propertySyntaxs = z.DescendantNodes().OfType<PropertyDeclarationSyntax>();

                    foreach (var propertySyntax in propertySyntaxs)
                    {
                        var descendantNodes = propertySyntax.DescendantNodes().ToList();
                        var descendantNodeCount = descendantNodes.Count;

                        var startingIndexForGetterOrSetter = FindStartingIndexForGetterOrSetter(descendantNodes);
                        if (startingIndexForGetterOrSetter < 0)
                        {
                            continue;
                        }

                        sb.AppendLine(string.Empty);
                        sb.AppendLine($"        public {propertySyntax.Type} {propertySyntax.Identifier}");
                        sb.AppendLine("        {");

                        var propertyName = "{PropertyName}";
                        var paramString = $"nameof({propertySyntax.Identifier})";

                        // Index 0 + N is the full type with namespace for 0, and each namespace following after ending with type.
                        // Index N + 1 is combined get and/or set (set is presented if existed)
                        // Index N + 2 is get or set depending the order written in the code;
                        // Index N + 3 is set or get depending the order written in the code; (set/get is presented if existed)
                        var typeNode = descendantNodes[0];
                        var firstPresentIndex = startingIndexForGetterOrSetter + 1;
                        var secondPresentIndex = firstPresentIndex + 1;

                        if (descendantNodeCount > firstPresentIndex)
                        {
                            var descendantNode = descendantNodes[firstPresentIndex];
                            var code = GetPropertyBody(propertyName, paramString, typeNode, descendantNode);

                            sb.AppendLine(code);
                        }

                        if (descendantNodeCount > secondPresentIndex)
                        {
                            var descendantNode = descendantNodes[secondPresentIndex];
                            var code = GetPropertyBody(propertyName, paramString, typeNode, descendantNode);

                            sb.AppendLine(code);
                        }

                        sb.AppendLine("        }");
                        sb.AppendLine(string.Empty);
                    }

                    var methods = z.DescendantNodes().OfType<MethodDeclarationSyntax>();

                    foreach (var method in methods)
                    {
                        var formattedString = method.ParameterList.Parameters
                            .Aggregate(
                                "{MethodName}",
                                (acc, next) =>
                                {
                                    var capitalizeIdentifier =
                                        char.ToUpper(next.Identifier.ToString()[0]) + next.Identifier.ToString().Substring(1);
                                    return acc + " - " + "{" + capitalizeIdentifier + "}";
                                });
                        var paramString = method.ParameterList.Parameters
                            .Aggregate($"nameof({method.Identifier})", (acc, next) => $"{acc}, {next.Identifier}");

                        var asyncKeyword = string.Empty;
                        if (method.ReturnType.ToString().Contains("Task<"))
                        {
                            asyncKeyword = "async ";
                        }

                        var combined =
                            $"public {asyncKeyword}{method.ReturnType} {method.Identifier}{method.TypeParameterList}{method.ParameterList} {method.ConstraintClauses}";
                        sb.AppendLine($"        {combined}");
                        sb.AppendLine("        {");

                        // Assign default value for out parameter.
                        foreach (var parameter in method.ParameterList.Parameters)
                        {
                            if (!parameter.Modifiers.Any(modifier => modifier.IsKind(SyntaxKind.OutKeyword)))
                            {
                                continue;
                            }

                            sb.AppendLine($"            {parameter.Identifier} = default;");
                        }

                        sb.AppendLine($"            _actionHandler?.Invoke(\"{formattedString}\", {paramString});");
                        if (string.CompareOrdinal(method.ReturnType.ToString(), "void") != 0)
                        {
                            sb.AppendLine("            return default;");
                        }

                        sb.AppendLine("        }");
                        sb.AppendLine(string.Empty);
                    }
                }
            }

            return sb.ToString().TrimEnd();
        }

        private static int FindStartingIndexForGetterOrSetter(IEnumerable<SyntaxNode> descendantNodes) =>
            descendantNodes
                .Select((node, i) => new { Node = node, Index = i })
                .FirstOrDefault(item => item.Node.ToFullString().Contains("{ "))?.Index ?? -1;

        private static string GetPropertyBody(
            string propertyName,
            string paramString,
            SyntaxNode typeNode,
            SyntaxNode getOrSetNode)
        {
            var code = string.Empty;
            var strippedGetOrSetNode = getOrSetNode
                .ToFullString()
                .Replace(";", string.Empty)
                .TrimEnd();

            // By property definition, get or set only, no other possibility.
            if (strippedGetOrSetNode.Contains("get"))
            {
                var formattedString = $"{propertyName} - {strippedGetOrSetNode}";
                code = $@"
            {strippedGetOrSetNode}
            {{
                _actionHandler?.Invoke(""{formattedString}"", {paramString});
                return default({typeNode});
            }}
";
            }
            else
            {
                var formattedString = $"{propertyName} - {strippedGetOrSetNode}";
                code = $@"
            {strippedGetOrSetNode}
            {{
                _actionHandler?.Invoke(""{formattedString}"", {paramString});
            }}
";
            }

            // Removing starting empty line and ending empty line as using multi line string literal
            // adding empty line at the start and end.
            return code.TrimStart('\n', '\r').TrimEnd('\n', '\r');
        }
    }
}

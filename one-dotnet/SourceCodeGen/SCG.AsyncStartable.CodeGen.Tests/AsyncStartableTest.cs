using System;
using System.Diagnostics;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace TPFive.SCG.AsyncStartable.CodeGen.Tests;

using TPFive.SCG.AsyncStartable.Abstractions;
using TPFive.SCG.AsyncStartable.CodeGen;

public class AsyncStartableTest
{
    [SetUp]
    public void Setup()
    {
    }

    private static Compilation CreateCompilation(string source)
    {
        var references = AppDomain.CurrentDomain
            .GetAssemblies()
            .Where(_ => !_.IsDynamic && !string.IsNullOrWhiteSpace(_.Location))
            .Select(_ => MetadataReference.CreateFromFile(_.Location))
            .Concat(new[]
            {
                // add your app/lib specifics, e.g.:
                MetadataReference.CreateFromFile(typeof(AsyncStartableAttribute).GetTypeInfo().Assembly.Location)
            })
            .ToList();

        return CSharpCompilation.Create(
            "compilation",
            new[] { CSharpSyntaxTree.ParseText(source) },
            references,
            new CSharpCompilationOptions(OutputKind.ConsoleApplication));
    }

    [Test]
    public void DefaultUsage()
    {
        var code = @"
namespace TPFive.SCG.AsyncStartable.CodeGen.Tests
{
    using TPFive.SCG.AsyncStartable.Abstractions;

    [AsyncStartable]
    public sealed partial class ServiceImplementation
    {
    }
}
";
        var inputCompilation = CreateCompilation(code);

        var generator = new SourceGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver) driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);
        var runResult = driver.GetRunResult();
        var generatedSource = runResult.Results[0].GeneratedSources[0].SourceText.ToString();

        var generatedCode = @"
// <auto-generated />

using System.Threading;
using System.Threading.Tasks;
using Cysharp.Threading.Tasks;
using VContainer.Unity;

namespace TPFive.SCG.AsyncStartable.CodeGen.Tests
{
    /// <summary>
    /// This part deals setup in async manner.
    /// </summary>
    public sealed partial class ServiceImplementation :
        IAsyncStartable
    {
        /// <summary>
        /// Cancellation token source.
        /// </summary>
        private CancellationTokenSource _cancellationTokenSource = default;

        public async UniTask StartAsync(CancellationToken cancellationToken)
        {
            _cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            var success = false;
            try
            {
                cancellationToken.ThrowIfCancellationRequested();
                await SetupBegin(cancellationToken);
                success = true;
            }

            finally
            {
                // Call end method and pass success flag.
                await SetupEnd(success, cancellationToken);
            }
        }
    }
}
";

        Assert.IsTrue(generatedSource.Contains(generatedCode));
    }
    
    [Test]
    public void DifferentBeginEndHandlerUsage()
    {
        var code = @"
namespace TPFive.SCG.AsyncStartable.CodeGen.Tests
{
    using TPFive.SCG.AsyncStartable.Abstractions;

    [AsyncStartable(SetupBeginMethod = ""MyBegin"", SetupEndMethod = ""MyEnd"")]
    public sealed partial class ServiceImplementation
    {
    }
}
";
        var inputCompilation = CreateCompilation(code);

        var generator = new SourceGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver) driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);
        var runResult = driver.GetRunResult();
        var generatedSource = runResult.Results[0].GeneratedSources[0].SourceText.ToString();

        var generatedCode = @"
// <auto-generated />

using System.Threading;
using System.Threading.Tasks;
using Cysharp.Threading.Tasks;
using VContainer.Unity;

namespace TPFive.SCG.AsyncStartable.CodeGen.Tests
{
    /// <summary>
    /// This part deals setup in async manner.
    /// </summary>
    public sealed partial class ServiceImplementation :
        IAsyncStartable
    {
        /// <summary>
        /// Cancellation token source.
        /// </summary>
        private CancellationTokenSource _cancellationTokenSource = default;

        public async UniTask StartAsync(CancellationToken cancellationToken)
        {
            _cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            var success = false;
            try
            {
                cancellationToken.ThrowIfCancellationRequested();
                await MyBegin(cancellationToken);
                success = true;
            }

            finally
            {
                // Call end method and pass success flag.
                await MyEnd(success, cancellationToken);
            }
        }
    }
}
";

        Assert.IsTrue(generatedSource.Contains(generatedCode));
    }
    
    [Test]
    public void WithExceptionListUsage()
    {
        var code = @"
namespace TPFive.SCG.AsyncStartable.CodeGen.Tests
{
    using TPFive.SCG.AsyncStartable.Abstractions;

    [AsyncStartable(ExceptionList = ""System.OperationCanceledException, System.Exception"")]
    public sealed partial class ServiceImplementation
    {
    }
}
";
        var inputCompilation = CreateCompilation(code);

        var generator = new SourceGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver) driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);
        var runResult = driver.GetRunResult();
        var generatedSource = runResult.Results[0].GeneratedSources[0].SourceText.ToString();

        var generatedCode = @"
// <auto-generated />

using System.Threading;
using System.Threading.Tasks;
using Cysharp.Threading.Tasks;
using VContainer.Unity;

namespace TPFive.SCG.AsyncStartable.CodeGen.Tests
{
    /// <summary>
    /// This part deals setup in async manner.
    /// </summary>
    public sealed partial class ServiceImplementation :
        IAsyncStartable
    {
        /// <summary>
        /// Cancellation token source.
        /// </summary>
        private CancellationTokenSource _cancellationTokenSource = default;

        /// <summary>
        /// Define exception handler for System.OperationCanceledException.
        /// </summary>
        private System.Func<System.OperationCanceledException, CancellationToken, Task> _funcOperationCanceledException = default;

        /// <summary>
        /// Define exception handler for System.Exception.
        /// </summary>
        private System.Func<System.Exception, CancellationToken, Task> _funcException = default;

        public async UniTask StartAsync(CancellationToken cancellationToken)
        {
            _cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            var success = false;
            try
            {
                cancellationToken.ThrowIfCancellationRequested();
                await SetupBegin(cancellationToken);
                success = true;
            }

            // Catch exception for System.OperationCanceledException
            catch (System.OperationCanceledException e)
            {
                // Check if exception handler is defined, called if defined.
                if (_funcOperationCanceledException != null)
                {
                    await _funcOperationCanceledException.Invoke(e, cancellationToken);
                }
            }

            // Catch exception for System.Exception
            catch (System.Exception e)
            {
                // Check if exception handler is defined, called if defined.
                if (_funcException != null)
                {
                    await _funcException.Invoke(e, cancellationToken);
                }
            }

            finally
            {
                // Call end method and pass success flag.
                await SetupEnd(success, cancellationToken);
            }
        }
    }
}
";

        Assert.IsTrue(generatedSource.Contains(generatedCode));
    }
}

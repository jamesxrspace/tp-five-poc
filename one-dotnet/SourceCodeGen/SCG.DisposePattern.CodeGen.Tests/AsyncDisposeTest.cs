using System.Diagnostics;
using System;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace TPFive.SCG.DisposePattern.CodeGen.Tests;

using TPFive.SCG.DisposePattern.Abstractions;
using TPFive.SCG.DisposePattern.CodeGen.AsyncDispose;

public class AsyncDisposeTest
{
    // Uncomment the following to see console output during test run.
    // [OneTimeSetUp]
    // public void StartTest()
    // {
    //     Trace.Listeners.Add(new ConsoleTraceListener());
    // }
    //
    // [OneTimeTearDown]
    // public void EndTest()
    // {
    //     Trace.Flush();
    // }

    [SetUp]
    public void Setup()
    {
    }

    private static Compilation CreateCompilation(string source)
    {
        var references = AppDomain.CurrentDomain
            .GetAssemblies()
            .Where(_ => !_.IsDynamic && !string.IsNullOrWhiteSpace(_.Location))
            .Select(_ => MetadataReference.CreateFromFile(_.Location))
            .Concat(new[]
            {
                // add your app/lib specifics, e.g.:
                MetadataReference.CreateFromFile(typeof(AsyncDisposeAttribute).GetTypeInfo().Assembly.Location),
                MetadataReference.CreateFromFile(typeof(DisposeAttribute).GetTypeInfo().Assembly.Location),
            })
            .ToList();

        return CSharpCompilation.Create(
            "compilation",
            new[] { CSharpSyntaxTree.ParseText(source) },
            references,
            new CSharpCompilationOptions(OutputKind.ConsoleApplication));
    }

    [Test]
    public void DefaultUsage()
    {
        var code = @"
namespace TPFive.SCG.DisposePattern.CodeGen.Tests
{
    using TPFive.SCG.DisposePattern.Abstractions;

    [AsyncDispose]
    public sealed partial class Service
    {
    }
}
";
        var inputCompilation = CreateCompilation(code);

        var generator = new SourceGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver) driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);
        var runResult = driver.GetRunResult();
        var generatedSource = runResult.Results[0].GeneratedSources[0].SourceText.ToString();

        var generatedCode = @"
// <auto-generated />

using System.Threading;
using System.Threading.Tasks;

namespace TPFive.SCG.DisposePattern.CodeGen.Tests
{
    /// <summary>
    /// This part deals dispose async. It works with DisposeAttribute.
    /// </summary>
    public sealed partial class Service :
        System.IAsyncDisposable
    {
        public async ValueTask DisposeAsync()
        {
            await HandleDisposeAsync().ConfigureAwait(true);
            // No dispose method
            System.GC.SuppressFinalize(this);
        }
    }
}
";

        Assert.IsTrue(generatedSource.Contains(generatedCode));
    }

    [Test]
    public void DifferentAsyncDisposeHandlerUsage()
    {
        var code = @"
namespace TPFive.SCG.DisposePattern.CodeGen.Tests
{
    using TPFive.SCG.DisposePattern.Abstractions;

    [AsyncDispose(AsyncDisposeHandler = ""MyHandler"")]
    public sealed partial class Service
    {
    }
}
";
        var inputCompilation = CreateCompilation(code);

        var generator = new SourceGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver) driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);
        var runResult = driver.GetRunResult();
        var generatedSource = runResult.Results[0].GeneratedSources[0].SourceText.ToString();

        var generatedCode = @"
// <auto-generated />

using System.Threading;
using System.Threading.Tasks;

namespace TPFive.SCG.DisposePattern.CodeGen.Tests
{
    /// <summary>
    /// This part deals dispose async. It works with DisposeAttribute.
    /// </summary>
    public sealed partial class Service :
        System.IAsyncDisposable
    {
        public async ValueTask DisposeAsync()
        {
            await MyHandler().ConfigureAwait(true);
            // No dispose method
            System.GC.SuppressFinalize(this);
        }
    }
}
";

        Assert.IsTrue(generatedSource.Contains(generatedCode));
    }

    [Test]
    public void UsageWithDisposeAttribute()
    {
        var code = @"
namespace TPFive.SCG.DisposePattern.CodeGen.Tests
{
    using TPFive.SCG.DisposePattern.Abstractions;

    [Dispose]
    [AsyncDispose]
    public sealed partial class Service
    {
    }
}
";
        var inputCompilation = CreateCompilation(code);

        var generator = new SourceGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);
        driver = (CSharpGeneratorDriver) driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);
        var runResult = driver.GetRunResult();
        var generatedSource = runResult.Results[0].GeneratedSources[0].SourceText.ToString();

        var generatedCode = @"
// <auto-generated />

using System.Threading;
using System.Threading.Tasks;

namespace TPFive.SCG.DisposePattern.CodeGen.Tests
{
    /// <summary>
    /// This part deals dispose async. It works with DisposeAttribute.
    /// </summary>
    public sealed partial class Service :
        System.IAsyncDisposable
    {
        public async ValueTask DisposeAsync()
        {
            await HandleDisposeAsync().ConfigureAwait(true);
            HandleDispose(disposing: false);
            System.GC.SuppressFinalize(this);
        }
    }
}
";

        Assert.IsTrue(generatedSource.Contains(generatedCode));
    }
}
